/* eslint-disable use-logger-not-console/replace-console-with-logger */
import { exec } from 'node:child_process'
import { readdir, readFile, writeFile } from 'node:fs/promises'
import { join, resolve, basename } from 'node:path'

import { Client } from '@modelcontextprotocol/sdk/client/index.js'
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js'
import { ListToolsResultSchema } from '@modelcontextprotocol/sdk/types.js'
import { type z } from 'zod'

// --- Configuration ---
/**
 * The base URL of your GitHub repository.
 * @example 'https://github.com/my-org/my-repo'
 */
const REPO_BASE_URL = 'https://github.com/Caesar2011/mcp-monorepo'

// --- ANSI Colors for Logging ---
const c = {
  reset: '\x1b[0m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  gray: '\x1b[90m',
}

// --- Type Definitions ---
interface PackageJson {
  name: string
  version: string
  description?: string
  author?: string | { name?: string }
  license?: string
  private?: boolean
  bin?: string | Record<string, string>
}

interface EnvVar {
  name: string
  description: string
  default: string
}

type MappedToolDefinition = z.infer<typeof ListToolsResultSchema>['tools'][number]
type PrimitiveSchemaDefinition = {
  type: 'string'
  description?: string
}
type ArraySchemaDefinition = {
  type: 'array'
  description?: string
  items: PropertySchemaDefinition
}
type ObjectSchemaDefinition = {
  type: 'object'
  description?: string
  properties: Record<string, PropertySchemaDefinition>
}
type PropertySchemaDefinition = PrimitiveSchemaDefinition | ArraySchemaDefinition | ObjectSchemaDefinition

// --- Main Orchestration ---
/**
 * Main function to generate a README for a single package.
 * Assumes the script is executed with the package's root as the CWD.
 */
async function main(): Promise<void> {
  const packagePath = process.cwd()
  const pkgJsonPath = join(packagePath, 'package.json')

  let pkgJson: PackageJson
  try {
    pkgJson = JSON.parse(await readFile(pkgJsonPath, 'utf-8'))
  } catch (error) {
    console.error(`${c.red}Error: package.json not found in CWD (${packagePath}).${c.reset}`)
    console.error(error)
    process.exit(1)
  }

  if (pkgJson.private) {
    console.log(`${c.gray}Skipping private package: ${pkgJson.name}${c.reset}`)
    return
  }

  console.log(`Generating README for package: ${c.yellow}${pkgJson.name}${c.reset}`)

  const isMcpServer = !!pkgJson.bin
  const docgenPath = join(packagePath, '.docgen')
  const monorepoRoot = resolve(packagePath, '../../')

  // 1. Gather all data sources
  const [partialReadme, envVars, changelog, toolList, otherServers] = await Promise.all([
    readFileIfExists(join(docgenPath, 'PARTIAL.md')),
    readJsonFile<EnvVar[]>(join(docgenPath, 'env.spec.json')),
    readFileIfExists(join(packagePath, 'CHANGELOG.md')),
    isMcpServer ? getToolData(packagePath, pkgJson) : Promise.resolve(undefined),
    findMonorepoPublicPackages(monorepoRoot),
  ])

  // 2. Assemble content sections
  const sections = [
    generateHeader(new Date()),
    generateTitleAndBadges(pkgJson, packagePath),
    partialReadme,
    generateUsageSection(pkgJson, envVars),
    generateEnvSection(envVars),
    generateToolsSection(toolList),
    generateOtherServersSection(otherServers, pkgJson.name),
    generateChangelogSection(changelog),
    generateFooter(pkgJson),
  ]

  // 3. Write the final README file
  const readmePath = join(packagePath, 'README.md')
  const finalReadme = sections.filter((s): s is string => !!s).join('\n\n')
  await writeFile(readmePath, finalReadme)

  // 4. Stage the generated README file to git
  await stageFileToGit(readmePath)

  console.log(`${c.green}âœ“ README for ${pkgJson.name} successfully generated and staged.${c.reset}`)
  //process.exit(0)
}

// --- Section Generators ---

function generateHeader(date: Date): string {
  return `<!--
  DO NOT EDIT THIS FILE DIRECTLY.
  IT IS AUTOMATICALLY GENERATED.
  Last generated: ${date.toISOString()}
-->`
}

function generateTitleAndBadges(pkgJson: PackageJson, packagePath: string): string {
  const packageDirName = basename(packagePath)
  const repoUrl = `${REPO_BASE_URL}/tree/main/packages/${packageDirName}`
  const badges = [
    `![version](https://img.shields.io/badge/version-${pkgJson.version}-blue)`,
    `![repo](https://img.shields.io/badge/monorepo-source-blue?logo=github&link=${encodeURIComponent(repoUrl)})`,
  ]
  return [`# ${pkgJson.name}`, badges.join(' '), pkgJson.description].filter(Boolean).join('\n\n')
}

/**
 * Generates the Usage section with npx command and Claude MCP Server configuration.
 */
function generateUsageSection(pkgJson: PackageJson, envVars: EnvVar[] | undefined): string | undefined {
  if (!pkgJson.bin) {
    return undefined
  }

  // Define the server key, e.g., 'weather-mcp' from '@mcp-monorepo/weather'
  const serverKey = pkgJson.name.split('/').pop() ?? pkgJson.name

  // Build the env object for the Claude config
  const claudeEnv: Record<string, string> = {}
  if (envVars) {
    for (const envVar of envVars) {
      // Use the default value, or a placeholder if it's required
      claudeEnv[envVar.name] = envVar.default.startsWith('<') ? `<Your ${envVar.name} Here>` : envVar.default
    }
  }

  const claudeConfig = {
    mcpServers: {
      [serverKey]: {
        command: 'npx',
        args: ['-y', pkgJson.name],
        env: claudeEnv,
      },
    },
  }

  const npxCommand = `\`\`\`bash\nnpx ${pkgJson.name}@latest\n\`\`\``
  const claudeJson = `\`\`\`json\n${JSON.stringify(claudeConfig, undefined, 2)}\n\`\`\``

  return `## Usage

You can run this MCP server directly using npx for local testing:

${npxCommand}

To integrate this server with a compatible AI model (like Claude), provide the following MCP server configuration:

${claudeJson}`
}

/**
 * Generates a markdown section listing other public MCP servers in the monorepo.
 */
function generateOtherServersSection(allPackages: PackageJson[], currentPackageName: string): string | undefined {
  const otherMcpServers = allPackages.filter((pkg) => pkg.name !== currentPackageName).filter((pkg) => !!pkg.bin)

  if (otherMcpServers.length === 0) {
    return undefined
  }

  const listItems = otherMcpServers.map(
    (pkg) =>
      `- **[${pkg.name}](https://www.npmjs.com/package/${pkg.name})**: ${pkg.description || 'No description available.'}`,
  )

  return `## Other MCP Servers

This monorepo contains several other MCP server packages available on npm. Each provides a distinct set of tools for use with the Model Context Protocol.

${listItems.join('\n')}`
}

function generateChangelogSection(changelog: string | undefined): string | undefined {
  const MAX_CHANGELOG_ENTRIES = 3

  if (!changelog || !changelog.trim()) {
    return undefined
  }
  const normalizedChangelog = changelog
    .replace(/\r\n/g, '\n')
    .replace(/\r/g, '\n')
    .replace(/^### .*\n/gm, '')

  const versionRegex = /^##\s+([\d.a-z-]+)\s*([\s\S]*?)(?=(^##\s+)|$)/gm
  const entries: string[] = []
  let match: RegExpMatchArray | null

  while ((match = versionRegex.exec(normalizedChangelog))) {
    if (entries.length >= MAX_CHANGELOG_ENTRIES) {
      break
    }
    const version = match[1]
    const content = (match[2] || '').trim()
    if (version && content) {
      entries.push(`### Version ${version}\n\n${content}`)
    }
  }
  if (entries.length === 0) {
    return undefined
  }
  return `## Recent Changes\n\n${entries.join('\n\n')}`
}

function generateEnvSection(envVars: EnvVar[] | undefined): string | undefined {
  if (!envVars || envVars.length === 0) return undefined
  const header = `| Variable | Description | Default |\n| :--- | :--- | :--- |`
  const rows = envVars.map((v) => `| \`${v.name}\` | ${v.description} | \`${v.default}\` |`)
  return `## Environment Variables\n\n${header}\n${rows.join('\n')}`
}

function generateToolsSection(toolList: MappedToolDefinition[] | undefined): string | undefined {
  if (!toolList || toolList.length === 0) return undefined
  const toolSections = toolList.map((def) => {
    const inputTable = def.inputSchema ? formatSchemaTable('Input Schema', def.inputSchema) : ''
    const outputTable = def.outputSchema ? formatSchemaTable('Output Schema', def.outputSchema) : ''
    return `### \`${def.name}\`\n\n**${def.title}** - ${def.description}\n\n${inputTable}\n${outputTable}`
  })
  return `## Tools\n\n${toolSections.join('\n\n---\n\n')}`
}

function formatSchemaTable(title: string, schema: MappedToolDefinition['inputSchema']): string {
  const header = `| Property | Type | Description |\n| :--- | :--- | :--- |`
  const rows: string[] = []

  const buildRows = (obj: ObjectSchemaDefinition, prefix = '') => {
    const properties = obj.properties ?? {}
    for (const [key, prop] of Object.entries(properties)) {
      const propName = prefix + key
      const description = prop.description || ''
      let type = prop.type || 'any'

      if (prop.type === 'object' && prop.properties) {
        rows.push(`| \`${propName}\` | \`object\` | ${description} |`)
        buildRows(prop, `${propName}.`)
        continue
      }
      if (prop.type === 'array' && prop.items) {
        type = `array of ${prop.items.type || 'any'}`
      }
      rows.push(`| \`${propName}\` | \`${type}\` | ${description} |`)
    }
  }

  buildRows((schema as ObjectSchemaDefinition) ?? { properties: {}, type: 'object' })
  if (rows.length === 0) return `**${title}**\n\n*This tool has no defined ${title.toLowerCase()}.*`
  return `**${title}**\n\n${header}\n${rows.join('\n')}`
}

function generateFooter(pkgJson: PackageJson): string {
  const authorName = typeof pkgJson.author === 'object' ? pkgJson.author.name : pkgJson.author
  const licenseText = pkgJson.license
    ? `This project is licensed under the ${pkgJson.license} License. See the [LICENSE](./LICENSE) file for details.`
    : ''
  return `---
## Authors

- ${authorName || 'The MCP Monorepo Team'}

## License

${licenseText}`
}

// --- Helper & Utility Functions ---

/**
 * Uses an MCP client to spawn the server process and request its tool list.
 */
async function getToolData(packagePath: string, pkgJson: PackageJson): Promise<MappedToolDefinition[] | undefined> {
  const binValue = typeof pkgJson.bin === 'string' ? pkgJson.bin : pkgJson.bin && Object.values(pkgJson.bin)[0]
  if (!binValue) {
    console.warn(`${c.yellow}Warning: No 'bin' found for ${pkgJson.name}, cannot advertise tools.${c.reset}`)
    return undefined
  }

  const executable = resolve(packagePath, binValue)
  console.log(`${c.gray}  -> Spawning server from '${executable}' to list tools...${c.reset}`)

  const transport = new StdioClientTransport({
    command: 'node',
    args: [executable],
    env: { ...process.env, TOOL_ADVISORY_ONLY: 'true' },
  })
  const client = new Client({ name: 'readme-generator-client', version: '1.0.0' }, { capabilities: {} })

  const stderrChunks: Buffer[] = []
  if (transport.stderr) {
    transport.stderr.on('data', (chunk: Buffer | string) => {
      stderrChunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk))
    })
  }

  try {
    await client.connect(transport)

    console.log(`${c.gray}  -> Client connected. Requesting tool list...${c.reset}`)
    const response = await client.request({ method: 'tools/list' }, ListToolsResultSchema)
    return response.tools
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : String(error)
    console.error(`${c.red}Error getting tool data for ${pkgJson.name}:${c.reset}\n${message}`)
    const stderrOutput = Buffer.concat(stderrChunks).toString('utf8').trim()
    if (stderrOutput) {
      console.error(`${c.gray}Server stderr:\n${stderrOutput}${c.reset}`)
    }
    return undefined
  } finally {
    console.log(`${c.gray}  -> Disconnecting client and closing transport...${c.reset}`)
    await client.close()
    await transport.close()
  }
}

async function readFileIfExists(filePath: string): Promise<string | undefined> {
  try {
    return await readFile(filePath, 'utf-8')
  } catch {
    return undefined
  }
}

async function readJsonFile<T>(filePath: string): Promise<T | undefined> {
  const content = await readFileIfExists(filePath)
  return content ? (JSON.parse(content) as T) : undefined
}

/**
 * Executes `git add` for the specified file path, with logging and error handling.
 */
async function stageFileToGit(filePath: string): Promise<void> {
  try {
    await new Promise<void>((resolve) => {
      // Use the absolute path for git to avoid ambiguity
      exec(`git add "${filePath}"`, (error, stdout, stderr) => {
        if (error) {
          // Soft fail: Warn instead of throwing an error, as git may not be available.
          console.warn(
            `${c.yellow}Warning: Could not stage ${basename(filePath)}. Is git installed and is this a git repository?${c.reset}`,
          )
          console.warn(`${c.gray}${stderr}${c.reset}`)
          resolve() // Resolve without error to allow the script to continue
          return
        }
        console.log(`${c.cyan}  -> Staged ${basename(filePath)} to git.${c.reset}`)
        resolve()
      })
    })
  } catch (gitError) {
    console.warn(
      `${c.yellow}Warning: An unexpected error occurred while staging ${basename(filePath)}.${c.reset}`,
      gitError,
    )
  }
}

/**
 * Scans the 'packages' directory of the monorepo to find all public packages.
 */
async function findMonorepoPublicPackages(monorepoRoot: string): Promise<PackageJson[]> {
  const packagesDir = join(monorepoRoot, 'packages')
  const results: PackageJson[] = []
  try {
    const packageFolders = await readdir(packagesDir, { withFileTypes: true })
    for (const dirent of packageFolders) {
      if (dirent.isDirectory()) {
        const pkgJsonPath = join(packagesDir, dirent.name, 'package.json')
        try {
          const pkgJson = await readJsonFile<PackageJson>(pkgJsonPath)
          if (pkgJson && !pkgJson.private) {
            results.push(pkgJson)
          }
        } catch {
          // Ignore folders without a valid package.json
        }
      }
    }
  } catch {
    console.warn(`${c.yellow}Could not read packages directory to find other servers.${c.reset}`)
  }
  return results
}

// --- Script Entry Point ---
main().catch((err) => {
  console.error(`${c.red}An unexpected top-level error occurred:${c.reset}`, err)
  process.exit(1)
})
